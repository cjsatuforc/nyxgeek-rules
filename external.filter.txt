# matches AD complexity requirements of 3 of 4 categories: number,upper,lower,special
[List.External:Filter_AD_Complexity_Min12]
void filter()
{
    int i, c ;
    int yesCAP;
    int yesLOW;
    int yesNUM;
    int yesSPECIAL;
    int yesMinLen;
    int yesMaxLen;
    int MinLen;
    int MaxLen;
    int score;

    MinLen = 12;
    MaxLen = 30;

    i = 0;
    yesCAP = 0;
    yesLOW = 0;
    yesNUM = 0;
    yesSPECIAL = 0;
    yesMinLen = 0;
    yesMaxLen = 1;
    while (c = word[i++])
    {
    if (c >= 'A' && c <= 'Z') { yesCAP = yesCAP + 1; }
    else if (c >= 'a' && c <= 'z') { yesLOW = yesLOW + 1; }
    else if (c >= '0' && c <= '9') { yesNUM = yesNUM + 1; }
    else {yesSPECIAL = yesSPECIAL + 1;}
    }
    if (i > MinLen) {yesMinLen = 1;}
    if (i >= MaxLen) {yesMaxLen = 0;}

    #now tally up if we have 3 of our 4 categories required
    if (yesCAP >= 1) { score = score + 1;}
    if (yesLOW >= 1) { score = score + 1;}
    if (yesNUM >= 1) { score = score + 1;}
    if (yesSPECIAL >= 1) { score = score + 1;}

    if ( ( score < 3 )|| yesMinLen==0 || yesMaxLen==0) { word = 0; return;}

   

}




#requires an UPPER, LOWER, SPECIAL -AND- A NUMBER
# This is an external filter for AD complexity, with min-length set to 12. this is 
# exactly the same as the one that comes with john except the min-length
# Usually it isn't worth using this, but for REALLY slow hashes like kerberos tickets
# it is faster.
[List.External:Filter_Complex_Basic12]
void filter()
{
    int i, c ;
    int yesCAP;
    int yesLOW;
    int yesNUM;
    int yesSPECIAL;
    int yesMinLen;
    int yesMaxLen;
    int MinLen;
    int MaxLen;

    MinLen = 12;
    MaxLen = 30;

    i = 0;
    yesCAP = 0;
    yesLOW = 0;
    yesNUM = 0;
    yesSPECIAL = 0;
    yesMinLen = 0;
    yesMaxLen = 1;
    while (c = word[i++])
    {
    if (c >= 'A' && c <= 'Z') { yesCAP = yesCAP + 1; }
    else if (c >= 'a' && c <= 'z') { yesLOW = yesLOW + 1; }
    else if (c >= '0' && c <= '9') { yesNUM = yesNUM + 1; }
    else {yesSPECIAL = yesSPECIAL + 1;}
    }
    if (i > MinLen) {yesMinLen = 1;}
    if (i >= MaxLen) {yesMaxLen = 0;}
    if (yesCAP < 1 || yesLOW < 1 || yesNUM < 1 || yesSPECIAL < 1 || yesMinLen==0 || yesMaxLen==0) { word = 0; return;}
}






# This is a modified version of the 'Policy' external filter that comes with John
# The default is to match ONLY passwords that are 8 characters exactly. This just
# allows for any passwords OVER 8 chars. You can use this in conjunction with
# --max-len=10 to limit it to passwords 8-10 characters if you want to curtail
# the max length


[List.External:Policy8plus]
int mask[0x100];

void init()
{
        int c;

        mask[0] = 0x100;
        c = 1;
        while (c < 0x100)
                mask[c++] = 0x200;

        c = 'a';
        while (c <= 'z')
                mask[c++] = 1;
        c = 'A';
        while (c <= 'Z')
                mask[c++] = 2;
        c = '0';
        while (c <= '9')
                mask[c++] = 4;
}

void filter()
{
        int i, seen;

/*
 * This loop ends when we see NUL (sets 0x100) or a disallowed character
 * (sets 0x200).
 */
        i = -1; seen = 0;
        while ((seen |= mask[word[++i]]) < 0x100)
                continue;

/*
 * We should have seen at least one character of each type (which "add up"
 * to 7) and then a NUL (adds 0x100), but not any other characters (would
 * add 0x200).  The length must be 8.
 */
        if (seen != 0x107 || i < 8)
                word = 0; // Does not conform to policy
}


